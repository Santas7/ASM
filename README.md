## Лабораторная работа номер 3 (6 вариант)

[условие лабы](https://drive.google.com/drive/folders/1Uc1NfYvonoCkSPvRP71gTaYT70sj0h1A)

[IDA PRO](https://disk.yandex.ru/d/lRz-qnLScunLtA)

В данной лабораторной работе предполагается использование
**специализированного ПО** для анализа кода исполняемых файлов. Итоговый
выбор ПО и метода анализа исполняемого файла не ограничивается –
анализировать файл, как угодно, и чем угодно, главное, чтобы поставленная
задача была решена.

_Выполнение л/р (всей л/р, а не только одного задания) на ОС
семейства Linux при сдаче засчитывается на уровень выше._

### Задание 1

В программе, полученной в ходе выполнения л/р 1 или л/р 2 (по
вашему выбору), заменить все макросы ввода-вывода SASM на вызовы
функций printf/scanf. Если ввод-вывод с консоли не был реализован,
его следует добавить. Для среднего и сложного уровня запрещается
использовать буферы в .data/.bss, память должна выделяться
динамически через malloc и освобождаться через free. Помните про
макрос CEXTERN.

#### CE

[Compiler Explorer](https://godbolt.org/z/cx64vv1PG)

![изображение](https://github.com/Santas7/ASM/assets/86359412/0737081c-3ab6-487c-9d04-49837c037bf0)


### Задание 2

Дана статическая библиотека, содержащая некоторый метод
проверки доступа. Вам необходимо реализовать программу, проходящую
данную проверку.
Уровни выполняются последовательно – для того, чтобы сдать
лабораторную на средний уровень, необходимо сначала сдать на легкий
уровень, аналогично со сложным уровнем.
Для анализа и отладки программы предлагается использовать IDA
Free. Аналогами являются открытый проект radare2 с интерфейсом iaito и
открытый проект Ghidra от АНБ (отсутствует отладчик, пригоден для
анализа). В самом простом варианте можно просто дизассемблировать
объектный файл с помощью онлайн-дизассемблера (объектный файл
придется извлечь из библиотеки) или напрямую с помощью objdump из
каталога <SASM_DIR>/MinGW64/bin командой objdump.exe -M intel,x86-64
-rdF -j .text -j .rdata --no-show-raw-insn FILE > OUT_FILE .
К сожалению, бесплатная IDA Free из-за ограничений может
анализировать только исполняемые файлы, но не статические библиотеки
или объектные файлы. Поэтому перед анализом функций необходимо
создать исполняемый файл.
Порядок выполнения:

    0) Открыть в архиваторе файл библиотеки, найти в текстовых файлах
    список экспортируемых символов, выбрать вашу функцию.
    1) В SASM указать библиотеку как зависимость, указать вашу
    функцию, как CEXTERN <ваш символ> после global CMAIN.
    2) В SASM вызвать вашу функцию. Программа не будет работать, но
    в исполняемый файл данная функция будет включена.
    3) Сохранить исполняемый файл (Файл -> Сохранить .exe)
    4) Открыть .EXE в IDA/iaito/Ghidra.
    5) Проанализировать функцию, определить ее параметры, а также
    условия, при которых проверка будет пройдена (в IDA/iaito можно
    воспользоваться отладчиком).
    6) Если необходимо – исправить программу в SASM, goto 3.

  ### ЛЕГКИЙ УРОВЕНЬ

  ![изображение](https://github.com/Santas7/ASM/assets/86359412/dcce5e19-5852-4893-83f5-987aecbf1ca9)

  функция на C:
  
  ```c++
  int __fastcall access6(int a1, __int16 a2, char a3, int a4)
    {
      if ( sin((double)(a4 - a2 - a3 - a1)) <= 0.0 )
      {
        puts("Access denied");
        exit(-1);
      }
      return puts("Access granted");
    } 
  ```
  
  ### MID УРОВЕНЬ
  
  ![изображение](https://github.com/Santas7/ASM/assets/86359412/faff9628-97a2-4d4c-b3af-8e7208ab8378)
  
  функция на C:
  
  ```c++
 namespace var6 {
        struct S {
            /**/
        };

        void access(__int64 a1, double a2, int a3) {
            __m128i v3 = _mm_setzero_si128(); 
            if ((static_cast<float>(static_cast<int>(*(_QWORD *)a1) * *(float *)(a1 + 12)) != static_cast<float>(static_cast<int>(*(float *)(a1 + 8)))) || (_mm_cvtsi128_si32(v3) < 0 == (_mm_movemask_pd(*(__m128d *)&a2) & 1))) {
                puts("Access denied");
                exit(-1);
            }
            return puts("Access granted");
        }
    }
  ```

  ### СЛОЖНЫЙ УРОВЕНЬ
  ![изображение](https://github.com/Santas7/ASM/assets/86359412/7d042ce7-3e55-43a3-89b0-08cd9dc7e5cd)

  функция на C:
  
  ```c++
  namespace var6 {
        struct S {
            /**/
        };

        class C {
        public:
            void access(__int64 a1, __int64 a2, const S& s) {
                if (a1 != *(_QWORD *)a2 || (checkFloatRatio(a2) && checkDoubleValue(a1))) {
                    puts("Access denied");
                    exit(-1);
                }
                return puts("Access granted");
            }

        private:
          /**/
        };
    }
  ```

